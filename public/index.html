<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <title>Buddy Chat - Grupo Interno</title>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    /* garantir box-sizing global para calcular altura/padding de forma consistente */
    *, *::before, *::after { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background: #ededed;
      margin: 0;
      padding: 20px;
      gap: 20px;
    }

    #loginContainer, #chatContainer {
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      padding: 20px;
    }

    #loginContainer {
      width: 380px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
    }

    #buttonDiv {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }

    #chatContainer {
      display: none;
      flex-direction: row;
      align-items: stretch; /* forçar que colunas tenham a mesma altura */
      gap: 20px;
    }

    #chatBox {
      display: flex;
      flex-direction: column;
      width: 500px;
      height: 500px;
      background: #fff;
      border-radius: 10px;
      overflow: hidden;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      background: #e5ddd5;
      border-bottom: 1px solid #ccc;
    }

    #inputContainer {
      display: flex;
      padding: 10px;
      background: #f0f0f0;
      gap: 8px;
    }

    input {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 20px;
      outline: none;
    }

    button {
      padding: 10px 16px;
      background: #128c7e;
      color: white;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }

    button:hover {
      background: #0d6e63;
    }

    /* === Mensagens tipo WhatsApp === */
    .message {
      max-width: 70%;
      padding: 8px 12px;
      border-radius: 10px;
      margin-bottom: 10px;
      clear: both;
      word-wrap: break-word;
    }

    .message.mine {
      background-color: #dcf8c6;
      float: right;
      text-align: right;
    }

    .message.other {
      background-color: #fff;
      float: left;
    }

    .meta {
      font-size: 0.75em;
      color: #777;
      margin-bottom: 4px;
    }

    .system {
      text-align: center;
      color: #888;
      font-style: italic;
      margin: 8px 0;
      clear: both;
    }

    /* === Participantes === */
    #participants {
      width: 250px;
      height: 500px;
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 10px;
      background: #fff;
      display: flex;
      flex-direction: column;
      align-items: center; /* centraliza títulos, lista e buddy card horizontalmente */
    }

    /* Lista de participantes com scroll */
    #participantsList {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden; 
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }

    #participants h4 {
      text-align: center; /* título centralizado */
      margin: 15px 0 20px 0;
      flex-shrink: 0; 
    }

    /* Buddy fixo no final */
    #buddyCard {
      width: 200px;
      background: #eef7ff;
      margin-top: 10px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #buddyCard img {
      width: 100%;
      height: auto;
      max-width: 200px;
      border-radius: 20px;
    }

    #buddySeparator {
      width: 100%;
      height: 1px;
      background: #ccc;
      margin: 10px 0 5px 0;
    }

    /* Título do Buddy */
    #buddyTitle {
      font-weight: bold;
      text-align: center;
      margin: 15px 0 0px 0;
    }
    

    .participant-card {
      width: 200px;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 6px;
      text-align: center;
      background: #f9f9f9;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .participant-card img {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      object-fit: cover;
    }

    .participant-name { font-weight: bold; }
    .participant-email { font-size: 0.8em; color: #666; }

  </style>
</head>
<body>
  <!-- === LOGIN === -->
  <div id="loginContainer">
    <h2>Bem-vindo ao Buddy Chat</h2>
    <p>Entre com sua conta Google para participar da conversa.</p>
    <div id="buttonDiv"></div> <!-- Google Login Button -->
  </div>

  <!-- === CHAT === -->
  <div id="chatContainer">
    <div id="chatBox">
      <div id="messages"></div>
      <div id="inputContainer">
        <input id="input" placeholder="Digite sua mensagem..." />
        <button id="send">Enviar</button>
      </div>
    </div>

    <div id="participants">
      <h4>Participantes</h4>
      <div id="participantsList"></div>
      <div id="buddySeparator"></div>
      <div id="buddyTitle">Buddy</div>
      <div id="buddyCard" class="participant-card">
        <img id="buddyImg" src="idle.png" alt="Buddy">
      </div>
    </div>
  </div>

  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#128c7e">
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(function(err){
        console.warn('SW registration failed:', err);
      });
    }
  </script>

  <script>
    // Normaliza strings Unicode para NFC (evita problemas com acentos combinantes)
    function normalizeStr(s) {
      try {
        return (typeof s === 'string' && s.normalize) ? s.normalize('NFC') : s;
      } catch (e) {
        return s;
      }
    }
    // Decodifica corretamente o payload de um JWT (tratando base64url + UTF-8)
    function jwtDecode(token) {
      const b64 = token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/');
      try {
        // tenta usar TextDecoder (mais robusto)
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const json = new TextDecoder('utf-8').decode(bytes);
        return JSON.parse(json);
      } catch (e) {
        // fallback legível em navegadores antigos
        const str = atob(b64);
        const json = decodeURIComponent(Array.prototype.map.call(str, c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
        return JSON.parse(json);
      }
    }
    // Pequeno avatar SVG embutido como fallback garantido (evita loops se default-avatar.png faltar)
    const DEFAULT_AVATAR_DATA = 'data:image/svg+xml;utf8,' + encodeURIComponent(
      '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64">' +
      '<rect rx="8" ry="8" width="64" height="64" fill="#f0f0f0"/>' +
      '<g transform="translate(8,8)">' +
      '<circle cx="24" cy="16" r="12" fill="#ddd"/>' +
      '<rect x="4" y="36" width="40" height="12" rx="6" fill="#e6e6e6"/>' +
      '</g>' +
      '</svg>'
    );
    // Resolve a URL de imagem do participante para um src válido.
    function resolveImageSrc(picture) {
      // if no picture provided, return embedded default avatar (guaranteed available)
      if (!picture) return DEFAULT_AVATAR_DATA;
      // aceitar data: urls
      if (picture.startsWith('data:')) return picture;
      // aceitar protocol-relative URLs //example.com/.. -> prefixa com protocolo atual
      if (picture.startsWith('//')) return location.protocol + picture;
      // aceitar caminhos absolutos /path -> prefixa com origin
      if (picture.startsWith('/')) return location.origin + picture;
      // aceitar http/https
      if (picture.startsWith('http://') || picture.startsWith('https://')) return picture;
      // se for algo pequeno (ex: a filename relativo) ou outro, return como está
      return picture;
    }
    const CLIENT_ID = "999630886871-38mjhji0liq3l3hqnamichkgq6bvvu9h.apps.googleusercontent.com";
    let username = "Usuário";
    let userEmail = "";
    let picture = "";
    let ws;

    function handleCredentialResponse(response) {
      const payload = jwtDecode(response.credential);
      console.log("Google payload:", payload);

      username = payload.name || payload.email || "Usuário";
      username = normalizeStr(username);
      userEmail = payload.email || "";
      picture = payload.picture
        ? payload.picture.replace("=s96-c", "=s200-c")
        : "default-avatar.png";
      // normalize/resolve picture to a usable src (handles protocol-relative and absolute paths)
      try {
        picture = resolveImageSrc(picture);
      } catch (e) {
        console.warn('Could not resolve picture URL', picture, e);
      }
      console.log('Resolved picture for sending join:', picture, 'raw payload.picture:', payload.picture);

      startChat();
    }

    function startChat() {
      document.getElementById("loginContainer").style.display = "none";
      document.getElementById("chatContainer").style.display = "flex";

      const messagesDiv = document.getElementById("messages");
      const input = document.getElementById("input");
      const sendBtn = document.getElementById("send");

      const scheme = location.protocol === "https:" ? "wss" : "ws";
      ws = new WebSocket(`${scheme}://${location.host}`);

      ws.onopen = () => {
        ws.send(JSON.stringify({ type: "join", user: username, email: userEmail, picture }));
      };

      let allMessages = [];

      ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);

        if (msg.type === "participants") {
          renderParticipants(msg.payload);
          return;
        }

        if (msg.type === "system" || msg.type === "message") {
          allMessages.push(msg);
          renderMessagesOrdered();
        }

        // Se for mensagem do Buddy, muda animação
        if (msg.type === "message" && msg.payload?.user === "Buddy") {
          const buddyImg = document.getElementById("buddyImg");
          buddyImg.src = msg.payload.picture || "idle.png";
        }
      };

      function renderMessagesOrdered() {
        allMessages.sort((a, b) => {
          const ta = a.payload?.time || 0;
          const tb = b.payload?.time || 0;
          return ta - tb;
        });

        messagesDiv.innerHTML = "";

        allMessages.forEach((m) => {
          if (m.type === "system") {
            appendSystem(m.payload);
          } else if (m.type === "message") {
            appendMessage(m.payload);
          }
        });
      }

      sendBtn.onclick = () => {
        const text = input.value.trim();
        if (!text) return;
        ws.send(JSON.stringify({ type: "message", user: username, email: userEmail, picture, text }));
        input.value = "";
      };

      input.addEventListener("keyup", (e) => {
        if (e.key === "Enter") sendBtn.click();
      });

      function appendSystem(s) {
        const el = document.createElement("div");
        el.className = "system";
        el.textContent = s.text;
        messagesDiv.appendChild(el);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      function appendMessage(m) {
        const el = document.createElement("div");
        const mine = (m.email === userEmail);
        el.className = "message " + (mine ? "mine" : "other");
        const userNameSafe = escapeHtml(normalizeStr(m.user));
        el.innerHTML = `
          <div class="meta">
            <b>${userNameSafe}</b> - ${formatTime(m.time)}
          </div>
          <div>${escapeHtml(m.text)}</div>
        `;
        messagesDiv.appendChild(el);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      }

      function renderParticipants(list) {
        const container = document.getElementById("participantsList");
        container.innerHTML = "";

        const sortedList = list.slice().sort((a, b) => {
          if (a.email === userEmail) return -1;
          if (b.email === userEmail) return 1;
          return a.user.localeCompare(b.user);
        });

        sortedList.forEach(p => {
          const card = document.createElement("div");
          card.className = "participant-card";

          const imgEl = document.createElement('img');
          imgEl.src = resolveImageSrc(p.picture) || DEFAULT_AVATAR_DATA;
          imgEl.alt = '';
          // reduzir layout shift e melhorar performance
          imgEl.loading = 'lazy';
          imgEl.width = 60;
          imgEl.height = 60;
          // se a imagem falhar, usa o fallback embutido e remove handler para evitar loop
          imgEl.onerror = function () { this.onerror = null; this.src = DEFAULT_AVATAR_DATA; };
          // debug: log participant picture and resolved src
          console.log('participant image:', { user: p.user, email: p.email, rawPicture: p.picture, resolved: imgEl.src });

          const isSelf = (p.email === userEmail);
          const normalized = normalizeStr(p.user);
          const displayName = isSelf
            ? `Eu (${escapeHtml(normalized)})`
            : escapeHtml(normalized);

          const nameEl = document.createElement('div');
          nameEl.className = 'participant-name';
          nameEl.innerHTML = displayName;

          const emailEl = document.createElement('div');
          emailEl.className = 'participant-email';
          emailEl.innerHTML = escapeHtml(p.email || '');

          card.appendChild(imgEl);
          card.appendChild(nameEl);
          card.appendChild(emailEl);

          container.appendChild(card);
        });
      }
    }

    window.onload = () => {
      google.accounts.id.initialize({
        client_id: CLIENT_ID,
        callback: handleCredentialResponse,
        use_fedcm_for_prompt: false,
        use_fedcm_for_button: false
      });
      google.accounts.id.renderButton(
        document.getElementById("buttonDiv"),
        { theme: "outline", size: "large", text: "continue_with", shape: "pill" }
      );
    };

    function formatTime(ts) {
      if (!ts) return "";
      const d = new Date(ts);
      return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
    }

    function escapeHtml(text) {
      if (!text) return "";
      return text.replace(/[&<>"']/g, m => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"
      }[m]));
    }
  </script>
</body>
</html>
